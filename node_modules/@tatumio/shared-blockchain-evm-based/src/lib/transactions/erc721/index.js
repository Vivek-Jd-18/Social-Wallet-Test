"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.erc721 = exports.mintMultipleCashbackSignedTransaction = void 0;
const tslib_1 = require("tslib");
const contracts_1 = require("../../contracts");
const evm_based_utils_1 = require("../../evm-based.utils");
const bignumber_js_1 = tslib_1.__importDefault(require("bignumber.js"));
const api_client_1 = require("@tatumio/api-client");
const erc721General_1 = require("../../contracts/erc721General");
const erc721Cashback_1 = require("../../contracts/erc721Cashback");
const shared_core_1 = require("@tatumio/shared-core");
const evm_based_sdk_errors_1 = require("../../evm-based.sdk.errors");
const shared_abstract_sdk_1 = require("@tatumio/shared-abstract-sdk");
const mintSignedTransactionMinter = (body) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const request = yield api_client_1.NftErc721OrCompatibleService.nftMintErc721(body);
    if (request)
        return request.txId;
    else
        throw new Error('Unable to mint NFT with a minter.');
});
const mintSignedTransaction = ({ body, web3, provider, addressTransformer, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { nonce, signatureId, fee, tokenId, url, fromPrivateKey } = body;
    const contractAddress = addressTransformer(body.contractAddress.trim());
    const to = addressTransformer(body.to.trim());
    const client = web3.getClient(provider, fromPrivateKey);
    const contract = new client.eth.Contract(erc721Cashback_1.Erc721Token_Cashback.abi, contractAddress);
    const alreadyMinted = yield evm_based_utils_1.evmBasedUtils.alreadyMinted(contract, tokenId);
    if (alreadyMinted) {
        throw new evm_based_sdk_errors_1.EvmBasedSdkError({ code: shared_abstract_sdk_1.SdkErrorCode.EVM_ERC721_CANNOT_PREPARE_MINT_ALREADY_MINTED });
    }
    if (contractAddress) {
        const tx = {
            from: 0,
            to: contractAddress,
            data: contract.methods.mintWithTokenURI(to, tokenId, url).encodeABI(),
            nonce: nonce,
        };
        return evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, signatureId, fromPrivateKey, fee === null || fee === void 0 ? void 0 : fee.gasLimit, fee === null || fee === void 0 ? void 0 : fee.gasPrice, provider);
    }
    throw new Error('Contract address should not be empty');
});
const mintCashbackSignedTransaction = ({ body, web3, provider, addressTransformer, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _a, _b, _c;
    const { fromPrivateKey, tokenId, nonce, fee, url, signatureId, cashbackValues } = body;
    const contractAddress = addressTransformer((_a = body.contractAddress) === null || _a === void 0 ? void 0 : _a.trim());
    const to = addressTransformer(body.to.trim());
    const erc20 = addressTransformer((_b = body.erc20) === null || _b === void 0 ? void 0 : _b.trim());
    const authorAddresses = (_c = body.authorAddresses) === null || _c === void 0 ? void 0 : _c.map((a) => addressTransformer(a === null || a === void 0 ? void 0 : a.trim()));
    const client = web3.getClient(provider, fromPrivateKey);
    const contract = new client.eth.Contract(erc721Cashback_1.Erc721Token_Cashback.abi, contractAddress);
    const cashbacks = cashbackValues;
    const cb = cashbacks.map((c) => `0x${new bignumber_js_1.default(client.utils.toWei(c, 'ether')).toString(16)}`);
    const alreadyMinted = yield evm_based_utils_1.evmBasedUtils.alreadyMinted(contract, tokenId);
    if (alreadyMinted) {
        throw new evm_based_sdk_errors_1.EvmBasedSdkError({ code: shared_abstract_sdk_1.SdkErrorCode.EVM_ERC721_CANNOT_PREPARE_MINT_ALREADY_MINTED });
    }
    if (contractAddress) {
        const tx = {
            from: 0,
            to: contractAddress,
            data: erc20
                ? contract.methods.mintWithCashback(to, tokenId, url, authorAddresses, cb, erc20).encodeABI()
                : contract.methods.mintWithCashback(to, tokenId, url, authorAddresses, cb).encodeABI(),
            nonce,
        };
        return evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, signatureId, fromPrivateKey, fee === null || fee === void 0 ? void 0 : fee.gasLimit, fee === null || fee === void 0 ? void 0 : fee.gasPrice, provider);
    }
    throw new Error('Contract address should not be empty!');
});
const mintMultipleCashbackSignedTransaction = ({ body, web3, provider, addressTransformer, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _d, _e, _f, _g;
    const { fromPrivateKey, tokenId, url, nonce, signatureId, cashbackValues, fee } = body;
    const contractAddress = addressTransformer((_d = body.contractAddress) === null || _d === void 0 ? void 0 : _d.trim());
    const to = (_e = body.to) === null || _e === void 0 ? void 0 : _e.map((a) => addressTransformer(a === null || a === void 0 ? void 0 : a.trim()));
    const erc20 = addressTransformer((_f = body.erc20) === null || _f === void 0 ? void 0 : _f.trim());
    const authorAddresses = (_g = body.authorAddresses) === null || _g === void 0 ? void 0 : _g.map((i) => i === null || i === void 0 ? void 0 : i.map((j) => addressTransformer(j === null || j === void 0 ? void 0 : j.trim())));
    const client = web3.getClient(provider, fromPrivateKey);
    const contract = new client.eth.Contract(erc721Cashback_1.Erc721Token_Cashback.abi, contractAddress);
    const cashbacks = cashbackValues;
    const cb = cashbacks.map((cashback) => cashback.map((c) => `0x${new bignumber_js_1.default(client.utils.toWei(c, 'ether')).toString(16)}`));
    const tx = {
        from: 0,
        to: contractAddress,
        data: erc20
            ? contract.methods.mintMultipleCashback(to, tokenId, url, authorAddresses, cb, erc20).encodeABI()
            : contract.methods.mintMultipleCashback(to, tokenId, url, authorAddresses, cb).encodeABI(),
        nonce,
    };
    return evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, signatureId, fromPrivateKey, fee === null || fee === void 0 ? void 0 : fee.gasLimit, fee === null || fee === void 0 ? void 0 : fee.gasPrice, provider);
});
exports.mintMultipleCashbackSignedTransaction = mintMultipleCashbackSignedTransaction;
const mintMultipleSignedTransaction = ({ body, web3, provider, addressTransformer, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _h, _j;
    const { fromPrivateKey, tokenId, url, nonce, signatureId, fee } = body;
    const contractAddress = addressTransformer((_h = body.contractAddress) === null || _h === void 0 ? void 0 : _h.trim());
    const to = (_j = body.to) === null || _j === void 0 ? void 0 : _j.map((a) => addressTransformer(a === null || a === void 0 ? void 0 : a.trim()));
    const client = yield web3.getClient(provider, fromPrivateKey);
    const contract = new client.eth.Contract(erc721Cashback_1.Erc721Token_Cashback.abi, contractAddress);
    const tx = {
        from: undefined,
        to: contractAddress,
        data: contract.methods.mintMultiple(to, tokenId, url).encodeABI(),
        nonce,
    };
    return evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, signatureId, fromPrivateKey, fee === null || fee === void 0 ? void 0 : fee.gasLimit, fee === null || fee === void 0 ? void 0 : fee.gasPrice, provider);
});
const burnSignedTransaction = ({ body, web3, provider, addressTransformer, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _k;
    const { fromPrivateKey, tokenId, fee, nonce, signatureId } = body;
    const contractAddress = addressTransformer((_k = body.contractAddress) === null || _k === void 0 ? void 0 : _k.trim());
    const client = web3.getClient(provider, fromPrivateKey);
    const contract = new client.eth.Contract(erc721Cashback_1.Erc721Token_Cashback.abi, contractAddress);
    const tx = {
        from: 0,
        to: contractAddress,
        data: contract.methods.burn(tokenId).encodeABI(),
        nonce,
    };
    return evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, signatureId, fromPrivateKey, fee === null || fee === void 0 ? void 0 : fee.gasLimit, fee === null || fee === void 0 ? void 0 : fee.gasPrice, provider);
});
const addMinterSignedTransaction = ({ body, web3, provider, addressTransformer, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _l, _m;
    const { fromPrivateKey, fee, nonce, signatureId } = body;
    const contractAddress = addressTransformer((_l = body.contractAddress) === null || _l === void 0 ? void 0 : _l.trim());
    const minter = addressTransformer((_m = body.minter) === null || _m === void 0 ? void 0 : _m.trim());
    const client = web3.getClient(provider, fromPrivateKey);
    const contract = new client.eth.Contract(erc721General_1.Erc721Token_General.abi, contractAddress);
    const tx = {
        from: 0,
        to: contractAddress,
        data: contract.methods
            .grantRole('0x9f2df0fed2c77648de5860a4cc508cd0818c85b8b8a1ab4ceeef8d981c8956a6', minter)
            .encodeABI(),
        nonce,
    };
    return evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, signatureId, fromPrivateKey, fee === null || fee === void 0 ? void 0 : fee.gasLimit, fee === null || fee === void 0 ? void 0 : fee.gasPrice, provider);
});
const transferSignedTransaction = ({ body, web3, provider, addressTransformer, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _o, _p;
    const { fromPrivateKey, tokenId, fee, nonce, signatureId, value, provenance, provenanceData, tokenPrice } = body;
    const contractAddress = addressTransformer((_o = body.contractAddress) === null || _o === void 0 ? void 0 : _o.trim());
    const to = addressTransformer((_p = body.to) === null || _p === void 0 ? void 0 : _p.trim());
    const client = yield web3.getClient(provider, fromPrivateKey);
    const contract = new client.eth.Contract(provenance ? contracts_1.Erc721_Provenance.abi : erc721Cashback_1.Erc721Token_Cashback.abi, contractAddress);
    const dataBytes = provenance
        ? Buffer.from(provenanceData + "'''###'''" + client.utils.toWei(tokenPrice, 'ether'), 'utf8')
        : '';
    const tokenData = provenance
        ? contract.methods.safeTransfer(to, tokenId, `0x${dataBytes.toString('hex')}`).encodeABI()
        : contract.methods.safeTransfer(to, tokenId).encodeABI();
    const tx = {
        from: 0,
        to: contractAddress,
        data: tokenData,
        nonce,
        value: value ? `0x${new bignumber_js_1.default(value).multipliedBy(1e18).toString(16)}` : undefined,
    };
    return evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, signatureId, fromPrivateKey, fee === null || fee === void 0 ? void 0 : fee.gasLimit, fee === null || fee === void 0 ? void 0 : fee.gasPrice, provider);
});
const updateCashbackForAuthorSignedTransaction = ({ body, web3, provider, addressTransformer, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _q;
    const { fromPrivateKey, cashbackValue, tokenId, fee, nonce, signatureId } = body;
    const contractAddress = addressTransformer((_q = body.contractAddress) === null || _q === void 0 ? void 0 : _q.trim());
    const client = yield web3.getClient(provider, fromPrivateKey);
    const contract = new client.eth.Contract(erc721Cashback_1.Erc721Token_Cashback.abi, contractAddress);
    const tx = {
        from: undefined,
        to: contractAddress,
        data: contract.methods
            .updateCashbackForAuthor(tokenId, `0x${new bignumber_js_1.default(client.utils.toWei(cashbackValue, 'ether')).toString(16)}`)
            .encodeABI(),
        nonce,
    };
    return evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, signatureId, fromPrivateKey, fee === null || fee === void 0 ? void 0 : fee.gasLimit, fee === null || fee === void 0 ? void 0 : fee.gasPrice, provider);
});
const deploySignedTransaction = ({ body, web3, provider, addressTransformer, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    const { fromPrivateKey, fee, name, symbol, nonce, signatureId, provenance, cashback, publicMint } = body;
    if (provenance && cashback) {
        throw new Error('Only one of provenance or cashback must be present and true.');
    }
    const client = yield web3.getClient(provider, fromPrivateKey);
    let abi = erc721General_1.Erc721Token_General.abi;
    let deployData = erc721General_1.Erc721Token_General.bytecode;
    if (body.provenance) {
        abi = contracts_1.Erc721_Provenance.abi;
        deployData = contracts_1.Erc721_Provenance.bytecode;
    }
    else if (body.cashback) {
        abi = erc721Cashback_1.Erc721Token_Cashback.abi;
        deployData = erc721Cashback_1.Erc721Token_Cashback.bytecode;
    }
    const contract = new client.eth.Contract(abi);
    const deploy = contract.deploy({
        arguments: [name, symbol, publicMint !== null && publicMint !== void 0 ? publicMint : false],
        data: deployData,
    });
    const tx = {
        from: 0,
        data: deploy.encodeABI(),
        nonce,
    };
    return evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, signatureId, fromPrivateKey, fee === null || fee === void 0 ? void 0 : fee.gasLimit, fee === null || fee === void 0 ? void 0 : fee.gasPrice, provider);
});
const mintProvenanceSignedTransaction = ({ body, web3, provider, addressTransformer, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _r, _s, _t, _u;
    const { fromPrivateKey, tokenId, nonce, fee, url, signatureId, cashbackValues, fixedValues } = body;
    const contractAddress = addressTransformer((_r = body.contractAddress) === null || _r === void 0 ? void 0 : _r.trim());
    const to = addressTransformer((_s = body.to) === null || _s === void 0 ? void 0 : _s.trim());
    const erc20 = addressTransformer((_t = body.erc20) === null || _t === void 0 ? void 0 : _t.trim());
    const authorAddresses = (_u = body.authorAddresses) === null || _u === void 0 ? void 0 : _u.map((i) => addressTransformer(i === null || i === void 0 ? void 0 : i.trim()));
    const client = web3.getClient(provider, fromPrivateKey);
    const contract = new client.eth.Contract(contracts_1.Erc721_Provenance.abi, contractAddress);
    const cb = [];
    const fval = [];
    const authors = [];
    if (authorAddresses && cashbackValues && fixedValues) {
        cashbackValues.forEach((c) => cb.push(`0x${new bignumber_js_1.default(c).multipliedBy(100).toString(16)}`));
        fixedValues.forEach((c) => fval.push(`0x${new bignumber_js_1.default(client.utils.toWei(c, 'ether')).toString(16)}`));
        authorAddresses === null || authorAddresses === void 0 ? void 0 : authorAddresses.map((a) => authors.push(a));
    }
    const alreadyMinted = yield evm_based_utils_1.evmBasedUtils.alreadyMinted(contract, tokenId);
    if (alreadyMinted) {
        throw new evm_based_sdk_errors_1.EvmBasedSdkError({ code: shared_abstract_sdk_1.SdkErrorCode.EVM_ERC721_CANNOT_PREPARE_MINT_ALREADY_MINTED });
    }
    const data = erc20
        ? contract.methods.mintWithTokenURI(to, tokenId, url, authors, cb, fval, erc20)
        : contract.methods.mintWithTokenURI(to, tokenId, url, authors, cb, fval);
    if (contractAddress) {
        const tx = {
            from: 0,
            to: contractAddress,
            data: data.encodeABI(),
            nonce,
        };
        return evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, signatureId, fromPrivateKey, fee === null || fee === void 0 ? void 0 : fee.gasLimit, fee === null || fee === void 0 ? void 0 : fee.gasPrice, provider);
    }
    throw new Error('Contract address should not be empty!');
});
const mintMultipleProvenanceSignedTransaction = ({ body, web3, provider, addressTransformer, }) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
    var _v, _w, _x, _y;
    const { fromPrivateKey, tokenId, url, nonce, signatureId, cashbackValues, fixedValues, fee } = body;
    const contractAddress = addressTransformer((_v = body.contractAddress) === null || _v === void 0 ? void 0 : _v.trim());
    const to = (_w = body.to) === null || _w === void 0 ? void 0 : _w.map((a) => addressTransformer(a === null || a === void 0 ? void 0 : a.trim()));
    const erc20 = addressTransformer((_x = body.erc20) === null || _x === void 0 ? void 0 : _x.trim());
    const authorAddresses = (_y = body.authorAddresses) === null || _y === void 0 ? void 0 : _y.map((i) => i === null || i === void 0 ? void 0 : i.map((j) => addressTransformer(j === null || j === void 0 ? void 0 : j.trim())));
    const client = yield web3.getClient(provider, fromPrivateKey);
    const contract = new client.eth.Contract(contracts_1.Erc721_Provenance.abi, contractAddress);
    const cb = [];
    const fv = [];
    if (authorAddresses && cashbackValues && fixedValues) {
        for (let i = 0; i < cashbackValues.length; i++) {
            const cb2 = [];
            const fv2 = [];
            for (let j = 0; j < cashbackValues[i].length; j++) {
                cb2.push(`0x${new bignumber_js_1.default(cashbackValues[i][j]).multipliedBy(100).toString(16)}`);
                fv2.push(`0x${new bignumber_js_1.default(client.utils.toWei(fixedValues[i][j], 'ether')).toString(16)}`);
            }
            cb.push(cb2);
            fv.push(fv2);
        }
    }
    const tx = {
        from: 0,
        to: contractAddress,
        data: erc20
            ? contract.methods.mintMultiple(to, tokenId, url, authorAddresses !== null && authorAddresses !== void 0 ? authorAddresses : [], cb, fv, erc20).encodeABI()
            : contract.methods.mintMultiple(to, tokenId, url, authorAddresses !== null && authorAddresses !== void 0 ? authorAddresses : [], cb, fv).encodeABI(),
        nonce,
    };
    return evm_based_utils_1.evmBasedUtils.prepareSignedTransactionAbstraction(client, tx, web3, signatureId, fromPrivateKey, fee === null || fee === void 0 ? void 0 : fee.gasLimit, fee === null || fee === void 0 ? void 0 : fee.gasPrice, provider);
});
const isUsingNftMinter = (body) => {
    return 'minter' in body;
};
const erc721 = ({ blockchain, web3, broadcastFunction, addressTransformer = (address) => address, }) => {
    const chain = shared_core_1.blockchainHelper.getDefaultCurrencyByBlockchain(blockchain);
    return {
        prepare: {
            /**
             * Sign mint ERC 721 transaction with private keys locally. Nothing is broadcast to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction data to be broadcast to blockchain.
             */
            mintSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return mintSignedTransaction({ body, web3, provider, addressTransformer }); }),
            /**
             * Sign mint ERC 721 transaction with cashback via private keys locally. Nothing is broadcast to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction data to be broadcast to blockchain.
             */
            mintCashbackSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return mintCashbackSignedTransaction({ body, web3, provider, addressTransformer }); }),
            /**
             * Sign mint multiple ERC 721 Cashback transaction with private keys locally. Nothing is broadcast to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction data to be broadcast to blockchain.
             */
            mintMultipleCashbackSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return (0, exports.mintMultipleCashbackSignedTransaction)({ body, web3, provider, addressTransformer }); }),
            /**
             * Sign mint multiple ERC 721 transaction with private keys locally. Nothing is broadcast to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction data to be broadcast to blockchain.
             */
            mintMultipleSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return mintMultipleSignedTransaction({ body, web3, provider, addressTransformer }); }),
            /**
             * Sign burn ERC 721 transaction with private keys locally. Nothing is broadcast to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction data to be broadcast to blockchain.
             */
            burnSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return burnSignedTransaction({ body, web3, provider, addressTransformer }); }),
            /**
             * Sign transfer ERC 721 transaction with private keys locally. Nothing is broadcast to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction data to be broadcast to blockchain.
             */
            transferSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return transferSignedTransaction({ body, web3, provider, addressTransformer }); }),
            /**
             * Sign update cashback ERC 721 transaction with private keys locally. Nothing is broadcast to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction data to be broadcast to blockchain.
             */
            updateCashbackForAuthorSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return updateCashbackForAuthorSignedTransaction({ body, web3, provider, addressTransformer }); }),
            /**
             * Sign deploy ERC 721 transaction with private keys locally. Nothing is broadcast to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction data to be broadcast to blockchain.
             */
            deploySignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return deploySignedTransaction({ body, web3, provider, addressTransformer }); }),
            /**
             * Sign mint ERC 721 provenance transaction with cashback via private keys locally. Nothing is broadcast to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction data to be broadcast to blockchain.
             */
            mintProvenanceSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return mintProvenanceSignedTransaction({ body, web3, provider, addressTransformer }); }),
            /**
             * Sign mint multiple ERC 721 Cashback transaction with private keys locally. Nothing is broadcast to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction data to be broadcast to blockchain.
             */
            mintMultipleProvenanceSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () { return mintMultipleProvenanceSignedTransaction({ body, web3, provider, addressTransformer }); }),
            /**
             * Sign add minter to ERC 721 with private keys locally. Nothing is broadcast to the blockchain.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction data to be broadcast to blockchain.
             */
            addMinterSignedTransaction: (body, provider) => addMinterSignedTransaction({ body, web3, provider, addressTransformer }),
        },
        send: {
            /**
             * Send BEP721 mint transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
             * This operation is irreversible.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction id of the transaction in the blockchain
             */
            mintSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (isUsingNftMinter(body)) {
                    return mintSignedTransactionMinter(body);
                }
                else if (body.signatureId) {
                    return api_client_1.NftErc721OrCompatibleService.nftMintErc721(Object.assign(Object.assign({}, body), { chain }));
                }
                else {
                    return broadcastFunction({
                        txData: yield mintSignedTransaction({ body, web3, provider, addressTransformer }),
                    });
                }
            }),
            /**
             * Send BEP721 mint transaction to the blockchain with cashback details. This method broadcasts signed transaction to the blockchain.
             * This operation is irreversible.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction id of the transaction in the blockchain
             */
            mintCashbackSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.NftErc721OrCompatibleService.nftMintErc721(Object.assign(Object.assign({}, body), { chain }));
                }
                else {
                    return broadcastFunction({
                        txData: yield mintCashbackSignedTransaction({
                            body,
                            web3,
                            provider,
                            addressTransformer,
                        }),
                    });
                }
            }),
            /**
             * Send BEP721 mint multiple transaction with cashback to the blockchain. This method broadcasts signed transaction to the blockchain.
             * This operation is irreversible.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction id of the transaction in the blockchain
             */
            mintMultipleCashbackSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.NftErc721OrCompatibleService.nftMintMultipleErc721(Object.assign(Object.assign({}, body), { chain }));
                }
                else {
                    return broadcastFunction({
                        txData: yield (0, exports.mintMultipleCashbackSignedTransaction)({
                            body,
                            web3,
                            provider,
                            addressTransformer,
                        }),
                    });
                }
            }),
            /**
             * Send BEP721 mint multiple transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
             * This operation is irreversible.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction id of the transaction in the blockchain
             */
            mintMultipleSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.NftErc721OrCompatibleService.nftMintMultipleErc721(Object.assign(Object.assign({}, body), { chain }));
                }
                else {
                    return broadcastFunction({
                        txData: yield mintMultipleSignedTransaction({
                            body,
                            web3,
                            provider,
                            addressTransformer,
                        }),
                    });
                }
            }),
            /**
             * Send BEP721 burn transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
             * This operation is irreversible.
             * @param body content of the transaction to broadcast
             * @param provider url of the  Server to connect to. If not set, default public server will be used.
             * @returns transaction id of the transaction in the blockchain
             */
            burnSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.NftErc721OrCompatibleService.nftBurnErc721(Object.assign(Object.assign({}, body), { chain }));
                }
                else {
                    return broadcastFunction({
                        txData: yield burnSignedTransaction({ body, web3, provider, addressTransformer }),
                    });
                }
            }),
            /**
             * Send BEP721 transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
             * This operation is irreversible.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction id of the transaction in the blockchain
             */
            transferSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.NftErc721OrCompatibleService.nftTransferErc721(Object.assign(Object.assign({}, body), { chain }));
                }
                else {
                    return broadcastFunction({
                        txData: yield transferSignedTransaction({ body, web3, provider, addressTransformer }),
                    });
                }
            }),
            /**
             * Send BEP721 update cashback to the blockchain. This method broadcasts signed transaction to the blockchain.
             * This operation is irreversible.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction id of the transaction in the blockchain
             */
            updateCashbackForAuthorSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.NftErc721OrCompatibleService.nftUpdateCashbackErc721(Object.assign(Object.assign({}, body), { chain }));
                }
                else {
                    return broadcastFunction({
                        txData: yield updateCashbackForAuthorSignedTransaction({
                            body,
                            web3,
                            provider,
                            addressTransformer,
                        }),
                    });
                }
            }),
            /**
             * Send BEP721 deploy to the blockchain. This method broadcasts signed transaction to the blockchain.
             * This operation is irreversible.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction id of the transaction in the blockchain
             */
            deploySignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.NftErc721OrCompatibleService.nftDeployErc721(Object.assign(Object.assign({}, body), { chain }));
                }
                else {
                    return broadcastFunction({
                        txData: yield deploySignedTransaction({ body, web3, provider, addressTransformer }),
                    });
                }
            }),
            /**
             * Send BEP721 mint provenance transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
             * This operation is irreversible.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction id of the transaction in the blockchain
             */
            mintProvenanceSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.NftErc721OrCompatibleService.nftMintErc721(Object.assign(Object.assign({}, body), { chain }));
                }
                else {
                    return broadcastFunction({
                        txData: yield mintProvenanceSignedTransaction({
                            body,
                            web3,
                            provider,
                            addressTransformer,
                        }),
                    });
                }
            }),
            /**
             * Send BEP721 mint multiple provenance transaction to the blockchain. This method broadcasts signed transaction to the blockchain.
             * This operation is irreversible.
             * @param body content of the transaction to broadcast
             * @param provider url of the Server to connect to. If not set, default public server will be used.
             * @returns transaction id of the transaction in the blockchain
             */
            mintMultipleProvenanceSignedTransaction: (body, provider) => tslib_1.__awaiter(void 0, void 0, void 0, function* () {
                if (body.signatureId) {
                    return api_client_1.NftErc721OrCompatibleService.nftMintMultipleErc721(Object.assign(Object.assign({}, body), { chain }));
                }
                else {
                    return broadcastFunction({
                        txData: yield mintMultipleProvenanceSignedTransaction({
                            body,
                            web3,
                            provider,
                            addressTransformer,
                        }),
                    });
                }
            }),
        },
    };
};
exports.erc721 = erc721;
//# sourceMappingURL=index.js.map